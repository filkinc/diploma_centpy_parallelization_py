"""
1) Активация окружения .venv:
source .venv/Scripts/activate
2) Чтобы локально запустить jupiter, надо поднять сервер следующей командой в окружении .venv:
python -m notebook
3) Чтобы выключить сервер
Ctrl + C
"""



"""
@dataclass — это специальный декоратор из модуля dataclasses в Python, который автоматически добавляет в класс:
- конструктор __init__;
- метод __repr__ для удобного вывода объекта;
- методы сравнения и другие, в зависимости от параметров.
Он позволяет легко создавать классы, которые в основном служат контейнерами для данных, сокращая шаблонный код.
@dataclass — это функция-декоратор, которая принимает класс, изменяет его, добавляя методы, и возвращает новый класс.
То есть по сути @dataclass это не просто метаданные, как в Java, а реальное преобразование класса во время загрузки.
"""

"""
В Python наследование происходит так:
класс-потомок указывается в скобках после имени класса, например:
class Pars2d(Pars1d): — Pars2d (дочь) наследует всё из Pars1d (родитель)

Множественное наследование: Python разрешает наследовать сразу от нескольких классов (в Java так нельзя)
"""

# import module — импортирует весь модуль, чтобы обращаться к элементам нужно писать module.element.

# В Python эта конструкция from import означает: «из модуля abc импортировать конкретно объекты ABC и abstractmethod»
from abc import ABC, abstractmethod

"""
ABC (abstract base class) — это абстрактный базовый класс, который сам по себе нельзя создать (instantiate), но он задает шаблон для других классов.
- Наследуясь от ABC и используя декоратор @abstractmethod, вы можете определить методы, которые обязаны реализовать все дочерние классы.
- Попытка создать объект класса, который не реализовал все абстрактные методы, приведет к ошибке TypeError.
- В Python нет отдельного синтаксиса для интерфейсов, как в Java.
- Вместо этого используют ABC для описания интерфейса — набора методов, которые должен поддерживать класс.
"""

"""
self - как this в Java только указан явно в конструкторе, так как у нас нет статического определения полей
"""

"""
Нет перегрузок в функциях, можно не указывать типы параметров в аргументах
Методы могут возвращать несколько обьектов, реализовано через кортежи (tuple)
"""

"""
Декоратор — это функция, которая принимает другую функцию или класс,
"оборачивает" её и возвращает модифицированный объект, добавляя функциональность.
@decorator — синтаксический сахар для say_hello = decorator(say_hello).
Отличие от Java:
- В Java аннотации — это метаинформация, которая не меняет код напрямую,
а предоставляет метаданные для компилятора, инструментов или рантайма.
- В Python декораторы (которые выглядят как аннотации @) — реальные вызовы функций,
которые могут менять класс или функцию во время загрузки.
"""

"""
pass — это пустая инструкция, заглушка, чтобы синтаксис был корректным.
В абстрактном методе pass означает, что метод не реализован, а лишь объявлен.
"""

"""
Что значит u[start:end]?
Выбирает элементы массива от индекса start (включительно) до end (не включая его).
- Если start опущен, берётся начало массива.
- Если end опущен, берётся до конца массива.
"""

"""
Кортеж (tuple) — это упорядоченная коллекция объектов различных типов, в которой элементы нельзя изменить после создания.
По сути, кортеж похож на список, но неизменяемый.
Кортежи создают при помощи круглых скобок или просто перечислением через запятую:
    my_tuple = (2, 4, 6, 8)
    my_tuple2 = 1, 2, 3
    empty_tuple = ()
    single_element = (5,)
Свойства кортежей:
Упорядоченность: элементы доступны по индексу, начиная с 0.
Неизменяемость: нельзя добавлять, удалять или менять элементы.
Гибкость по типам: можно хранить разные типы данных, включая числа, строки, списки и даже другие кортежи.

Тип данных  |  Описание                                        |  Аналог в Java Collections
------------+--------------------------------------------------+-----------------------------------------------------------
list        |  Упорядоченный, изменяемый список элементов      |  ArrayListилиLinkedList
tuple       |  Упорядоченный, неизменяемый набор элементов     |  Нет прямого аналога; скорее как final List или ImmutableList
dict        |  Отображение ключ -> значение (словарь)          |  HashMap,TreeMap
set         |  Неупорядоченное множество уникальных элементов  |  HashSet
"""

"""
(self.Nt + 1,) + self.u.shape - кортеж из одного числа
Оператор + добавляет элемент и получается (self.Nt + 1, self.u.shape)

Метод zeros возвращает массив заданной формы (одномерный, двумерный, любой), заполненный нулями
Метод shape это атрибут любого NumPy массива, который возвращает кортеж с размерами массива по каждой оси (например, число элементов по каждой размерности).
"""

"""
NamedTuple из стандартной библиотеки Python (typing или collections) — это лёгкий способ создать неизменяемый класс с именованными полями,
похожий на tuple, но с доступом по атрибутам вместо индексов.
Chex.dataclass от DeepMind Chex расширяет эту идею для JAX/ML, добавляя поддержку статической формы массивов (pytree) и автоматической проверки типов/форм

NamedTuple позволяет определять структуры данных декларативно:
Point = NamedTuple('Point', [('x', int), ('y', int)]).
Доступ по имени (point.x) делает код читаемым, сохраняя неизменяемость и эффективность памяти — идеально для функционального стиля.
Поддерживает методы, docstrings и значения по умолчанию, но запрещает мутации
"""

"""
Chex.dataclass — это декоратор @chex.dataclass, создающий dataclass с полной поддержкой JAX-трансформаций (jit, grad, vmap).
Он наследует от pytree, автоматически регистрируя вложенные массивы/структуры как листья для трассировки
"""

"""
Callable указывает, что значение является вызываемым объектом (функцией, лямбдой и т.д.), с указанием сигнатуры аргументов и возвращаемого типа.
По сути это как Function<T, R> или Predicate<T> в Java
Optional обозначает, что значение может быть типа T или None, эквивалентно Union[T, None]
"""

"""
PyTrees — это иерархические структуры данных в JAX, представляющие собой вложенные контейнеры Python (списки, кортежи, словари),
где листья — это массивы или примитивы, а узлы рекурсивно разворачиваются JAX для трансформаций (jit, grad, vmap)
Они позволяют работать со сложными nested структурами как с единым объектом, автоматически сохраняя структуру при flatten/unflatten.

По умолчанию JAX распознаёт следующие контейнеры как PyTrees:
lists: [jax.array(1), [2, 3]]
tuples: (array1, (array2, array3))
dicts: {'params': array, 'state': {'hidden': array}}
namedtuples / Chex.dataclass: пользовательские классы с pytree-поддержкой
None: как пустой узел
Любые другие типы (числа, строки, массивы) — листья. Пример: [1, {"a": 2, "b": (3, 4)}] имеет 4 листа: [1, 2, 4, 3], структура PyTreeDef([*, {"a": *, "b": (*, *) }])
"""

"""
Аннотация @property в Python превращает метод класса в свойство (property), которое выглядит и используется как обычный атрибут, но при обращении к нему вызывается метод
"""

"""
jnp.pad() в JAX — это функция для добавления "рамки" (padding) вокруг массива, аналог numpy.pad().
Используется для расширения формы массива без изменения данных
Аргумент mode:
'constant'(default) ->	Заполняет константой (0) -> [0,1,2,3,0]
'edge' -> Копирует крайние значения -> [1,1,2,3,3]
'wrap' -> Циклически повторяет -> [3,1,2,3,1]
'reflect' -> Отражает массив -> [2,1,2,3,2]
'empty' -> Неинициализированные (быстрее) -> [nan,1,2,3,nan]
"""


"""
Аннотация jit работает по следующему принципу:
При первой компиляции  она создает\строит вычислительный граф (схему или шаблон) операций,
(где вершины это операции (операции из JAX), а ребра это данные)
который оптимизируется (фьюжн, автодополнение векторизации, раскладка памяти и т.д.) компилятором XLA.
Этот граф затем реализуется как один кусок скомпилированного кода на CPU или GPU,
и работает для любых входных данных с той же формой и dtypes (важно: если форма изменится,
JAX сделает ещё одну компиляцию под новый случай)
Именно поэтому тяжеловесные методы laplacian и step вынесены отдельно,
чтобы оставить только примитивы JAX и обернуть в jit, для разовой компиляции и создания граф, который затем будет
использоваться на каждом временном слое для других числовых данных такого же типа.

Идея построения вычислительного графа:
Вычислительный граф строится из примитивных операций JAX (jnp.add, jnp.mul, jnp.exp, jnp.roll, матричное умножение, свёртки)
Когда мы вызываем метод с аннотацией jit, JAX один раз прогоняет этот метод на специальных абстрактных массивах.
Во время этого прогона все что реализовано через примитивы JAX записывается в вычислительный граф,
а все остальное (что не относится к JAX, отбрасывается при трассировке, либо делает функцию не‑jittable)
не попадает в граф и не оптимизируется. (строится внутреннее представление jaxpr,
а на основе jaxpr уже строится XLA‑граф и компилируется в машинный код)

Вместо множества маленьких Python‑вызовов NumPy‑функций мы описываем вычисление
как одну большую функцию на jax.numpy‑массивах
"""